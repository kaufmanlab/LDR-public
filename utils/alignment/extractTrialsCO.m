function trials = extractTrialsCO(data,timePeriod)
%% OVERVIEW

% This is a function for parcellating reaches to targets into components.

%% Parcellate trials.

% Correct kinematic offset.
data.Kinematics.ActualPos(:,2) = data.Kinematics.ActualPos(:,2) + 0.06;
data.TaskStateMasks.target(2,:) = data.TaskStateMasks.target(2,:) + 0.06;

% Get blocks where presentation is occuring. 
blocksOut = findBlocks(strcmp([data.TaskStateMasks.state_name],'Presentation1'));
blocksIn = findBlocks(strcmp([data.TaskStateMasks.state_name],'Presentation2'));

% Loop through, extract chunks specified.
count = 1;
for trial = 2:size(blocksOut,2)-1
    if blocksIn(trial).inds(1)+timePeriod(2)+1 <= size(data.SpikeCount,1) ...
        && blocksOut(trial).inds(end)-timePeriod(1)+1 > 0
        trials.neuralActivity(count).matrix = data.SpikeCount(...
            blocksOut(trial).inds(end)-timePeriod(1)+1:blocksIn(trial).inds(1)+timePeriod(2)+1, ...
            data.ActiveChannelMask).';
        trials.kinematics(count).matrix = data.Kinematics.ActualPos(...
            blocksOut(trial).inds(end)-timePeriod(1)+1:blocksIn(trial).inds(1)+timePeriod(2)+1,1:3);
        trials.kinematics(count).moveInds = find(strcmp( ...
            data.TaskStateMasks.state_name( ...
            blocksOut(trial).inds(end)-timePeriod(1)+1 ...
            :blocksIn(trial).inds(1)+timePeriod(2)+1),'Reach'));
        trials.targetOverTime(count).matrix = ...
            data.TaskStateMasks.target(1:3, ...
            blocksOut(trial).inds(end)-timePeriod(1)+1:blocksIn(trial).inds(1)+timePeriod(2)+1).';
        trials.kinematics(count).targetTo = ...
            trials.targetOverTime(count).matrix(1,1:3);
        trials.kinematics(count).angle = atan2(trials.kinematics(count).targetTo(3),trials.kinematics(count).targetTo(2));
        trials.kinematics(count).targetFrom = ...
            data.TaskStateMasks.target(1:3,blocksOut(trial).inds(1)-1).';
        trials.kinematics(count).end = ...
            blocksIn(trial).inds(1) + 10 - (blocksOut(trial).inds(end)-timePeriod(1)+1);
        trials.kinematics(count).out = 1;
        count = count+1;
    end
end
for trial = 2:size(blocksIn,2)-1
    if blocksOut(trial+1).inds(1)+timePeriod(3)+1 <= size(data.SpikeCount,1) ...
        && blocksIn(trial).inds(end)-timePeriod(4)+1 > 0 ...
        && abs(blocksIn(trial).inds(end) - blocksOut(trial+1).inds(1)) < 500
        trials.neuralActivity(count).matrix = data.SpikeCount(...
            blocksIn(trial).inds(end)-timePeriod(3)+1:blocksOut(trial+1).inds(1)+timePeriod(4)+1, ...
            data.ActiveChannelMask).';
        trials.kinematics(count).matrix = data.Kinematics.ActualPos(...
            blocksIn(trial).inds(end)-timePeriod(3)+1:blocksOut(trial+1).inds(1)+timePeriod(4)+1,1:3);
        trials.kinematics(count).moveInds = find(strcmp( ...
            data.TaskStateMasks.state_name( ...
            blocksIn(trial).inds(end)-timePeriod(3)+1 ...
            :blocksOut(trial+1).inds(1)+timePeriod(4)+1),'Center'));
        trials.targetOverTime(count).matrix = ...
            data.TaskStateMasks.target(1:3, ...
            blocksIn(trial).inds(end)-timePeriod(3)+1:blocksOut(trial+1).inds(1)+timePeriod(4)+1).';
        trials.kinematics(count).targetTo = ...
            trials.targetOverTime(count).matrix(1,1:3);
        trials.kinematics(count).targetFrom = ...
            data.TaskStateMasks.target(1:3,blocksIn(trial).inds(1)-1).';
        trials.kinematics(count).angle = atan2(trials.kinematics(count).targetFrom(3),trials.kinematics(count).targetFrom(2));
        trials.kinematics(count).end = ...
            blocksOut(trial+1).inds(1) + 10 - (blocksIn(trial).inds(end)-timePeriod(1)+1);
        trials.kinematics(count).out = 0;
        count = count+1;
    end
end

% Smooth kinematics a bit.
for trial = 1:size(trials.kinematics,2)
    for dim = 1:3
        % Filter out nans.
        allInds = 1:size(trials.kinematics(trial).matrix,1);
        nanInds = isnan(trials.kinematics(trial).matrix(:,dim));
        goodInds = allInds;
        goodInds(nanInds) = [];
        trials.kinematics(trial).matrix(:,dim) = interp1(goodInds, ...
            trials.kinematics(trial).matrix(goodInds,dim),allInds, ...
            'nearest','extrap');
        % Smooth.
        %trials.kinematics(trial).matrix(:,dim) = ...
        %    imgaussfilt(trials.kinematics(trial).matrix(:,dim),2,'padding', ...
        %    'symmetric','filterSize',31);
    end
end

end